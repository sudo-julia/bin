#!/usr/bin/env python3
"""Work with notes"""
from __future__ import annotations
import argparse
from datetime import date
from os import getenv
from pathlib import Path
import subprocess
import sys
from tempfile import NamedTemporaryFile


class Note:
    """Class to store details and modification methods of a note

    Attributes:
        note_name:  The name of the note
        filetype: The file extension of the note (md, txt, etc)
        note_dir: The directory that the note is located in
    """

    def __init__(self, note_name: str, filetype: str, note_dir: str):
        """Initialize variables"""
        self.note_name = note_name
        self.filetype = filetype
        self.note_dir = note_dir
        self.file: Path
        if "." in self.note_name:
            self.file = Path(f"{self.note_dir}/{self.note_name}")
        else:
            self.file = Path(f"{self.note_dir}/{self.note_name}.{self.filetype}")

    def create_note(self, editor: str) -> None:
        """Creates a note

        Attributes:
            editor: The name of the text editor to use for the note
        """
        try:
            self.file.parent.mkdir(parents=True, exist_ok=True)
            subprocess.run([editor, "--", self.file], check=True)
        except PermissionError as err:
            raise PermissionError from err
        except subprocess.CalledProcessError as err:
            raise NotImplementedError from err

    def get_notes(self) -> dict[str, str]:
        """Gets a dictionary of all available notes in note_dir

        Returns:
           A dictionary where the keys are note names and the values are strings to the
           note's filepath
        """
        notes: dict = {}
        # sort the notes so they're organized by date, more recent at the bottom
        for note in sorted(Path(self.note_dir).iterdir(), reverse=True):
            if not note.is_file():
                continue
            notes[note.name] = str(note.resolve())
        return notes

    def list_notes(self) -> None:
        """Prints all notes available in note_dir"""
        notes: dict[str, str] = self.get_notes()
        print(f"Notes in {self.note_dir}:")
        for note in notes:
            print(note)

    def select_note(self, prompt: str) -> Path:
        """Prompts the user to select a note from note_dir with fzf

        Attributes:
            prompt: The prompt for fzf to use during selection
        Returns:
            A Path object of the note
        """
        notes: dict[str, str] = self.get_notes()
        selected_note: str = ""
        cmd: str = "cat {} | fzf +m --ansi --prompt='{}' --preview='cat {}/{{}}'"
        with NamedTemporaryFile(mode="w+", encoding="utf-8") as tmpfile:
            try:
                # add note options to tmpfile for piping
                for note in notes:
                    tmpfile.write(note + "\n")
                tmpfile.seek(0)
                selected_note = (
                    subprocess.check_output(
                        cmd.format(tmpfile.name, prompt, self.note_dir),
                        shell=True,
                    )
                    .decode(sys.stdout.encoding)
                    .strip()
                )
            except subprocess.CalledProcessError as err:
                # exit peacefully if the user doesn't select a note
                if not selected_note:
                    raise SystemExit from err
                raise err
        return Path(notes[selected_note])

    def view_note(self) -> None:
        """Prints a note to the terminal"""
        try:
            with self.file.open(encoding="utf-8") as file:
                print(file.read())
        except FileNotFoundError as err:
            print_error(f"{self.file} does not exist")
            raise SystemExit(1) from err
        except PermissionError as err:
            raise err


def valid_filename(filename: str) -> bool:
    """Checks a filename for reserved characters"""
    if not filename:
        print_error("Empty input!")
        return False
    if filename[0] == "-":
        print_error("Filename cannot begin with a dash!")
        return False
    if len(filename) > 255:
        print_error("Filename cannot exceed 255 characters!")
    for reserved_char in ("/", "\0", ">", "<", "|", ":", "&", ";", "*", "!", "'", '"', "$"):
        if reserved_char in filename:
            print_error(f"Filename cannot contain '{reserved_char}'!")
            return False
    return True


def get_new_name(old_name: str) -> str:
    """Gets the new name of 'oldname' from user"""
    while True:
        new_name = input(f"Rename '{old_name}' to: ").casefold().strip()
        if not valid_filename(new_name):
            continue
        return new_name

def print_error(msg: str, warning: str = "ERR") -> None:
    """Prints an error message to stderr

    Attributes:
        msg: The message to print to stderr
        warning: The warning to prepend to the message, defaults to 'ERR'
    """
    print(f"[{warning}] {msg}", file=sys.stderr)


def parse_args() -> argparse.Namespace:
    """Parses arguments with argparse

    Returns:
        The namespace of arguments
    """
    parser: argparse.ArgumentParser = argparse.ArgumentParser()
    actions = parser.add_mutually_exclusive_group()
    actions.add_argument(
        "-d", "--delete", action="store_true", help="Delete an existing note"
    )
    actions.add_argument(
        "-e", "--edit", action="store_true", help="Edit an existing note"
    )
    actions.add_argument(
        "-l", "--list", action="store_true", help="List all created notes"
    )
    actions.add_argument("-r", "--rename", action="store_true", help="Rename a note")
    actions.add_argument(
        "-v", "--view", action="store_true", help="View an existing note"
    )
    # TODO: implement
    # parser.add_argument(
    #     "--decrypt",
    #     action="store_true",
    #     help="Decrypt a note before opening",
    # )
    parser.add_argument(
        "-f",
        "--filetype",
        default="md",
        help="Set the filetype of the new note (default: markdown)",
    )
    parser.add_argument(
        "--editor",
        default=getenv("EDITOR"),
        help="Chose the editor to use. (default: $EDITOR)",
    )
    # TODO: implement
    # parser.add_argument(
    #     "--encrypt",
    #     action="store_true",
    #     help="Encrypt a note with a password after writing",
    # )
    parser.add_argument(
        "--note_dir",
        default=f"{getenv('HOME')}/documents/personal/notes",
        help="Directory to store the note in",
    )
    parser.add_argument(
        "note",
        nargs="?",
        default=str(date.today()),
        help="The name of the note (default: today's date)",
    )

    return parser.parse_args()


def main():
    """Main control flow for the program"""
    args: argparse.Namespace = parse_args()
    if not valid_filename(args.note):
        raise SystemExit(1)
    note: Note = Note(args.note, args.filetype, args.note_dir)

    try:
        if args.delete:
            try:
                note.file = note.select_note("delete > ")
                note.file.unlink()
                print(f"Deleted '{note.file}'")
                return
            except PermissionError as err:
                raise PermissionError from err
        elif args.edit:
            note.file = note.select_note("edit > ")
        elif args.list:
            note.list_notes()
            raise SystemExit
        elif args.rename:
            note.file = note.select_note("rename > ")
            note.note_name = note.file.name
            new_file = f"{note.note_dir}/{get_new_name(note.note_name)}"
            note.file.rename(new_file)
            print(f"{note.file} -> {new_file}")
            raise SystemExit
        else:
            if args.view:
                note.view_note()
                raise SystemExit
    except KeyboardInterrupt:
        print_error("\nExiting.", "")
        raise SystemExit

    note.create_note(args.editor)


if __name__ == "__main__":
    main()
