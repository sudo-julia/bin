#!/usr/bin/env python3
"""create or edit a note file"""
from __future__ import annotations
import argparse
from datetime import date
from os import getenv
from pathlib import Path
import subprocess
import sys
from tempfile import NamedTemporaryFile


def create_note(file: str, editor: str) -> None:
    """create a note"""
    try:
        Path(file).parent.mkdir(parents=True, exist_ok=True)
        subprocess.run([editor, "--", file], check=True)
    except PermissionError as err:
        raise PermissionError from err
    except subprocess.CalledProcessError as err:
        raise NotImplementedError from err


def get_notes(note_dir: str) -> dict[str, str]:
    """return a dict of all notes in the note_dir {note_name: note_location}"""
    notes: dict = {}
    for note in Path(note_dir).iterdir():
        if not note.is_file():
            continue
        notes[note.name] = str(note.resolve())
    return notes


def list_notes(note_dir: str) -> None:
    """list all available notes"""
    notes: dict[str, str] = get_notes(note_dir)
    for note in notes:
        print(note.split(".")[0])


def select_note(note_dir: str, prompt: str) -> str:
    """select a note"""
    notes: dict[str, str] = get_notes(note_dir)
    selected_note: str = ""
    cmd: str = "cat {} | fzf +m --ansi --prompt='{}' --preview='cat {}/{{}}'"
    with NamedTemporaryFile(mode="w+") as tmpfile:
        try:
            with open(tmpfile.name, "w+", encoding="utf-8") as tmp:
                # add note options to tmpfile for piping
                for note in notes:
                    tmp.write(note + "\n")
                tmp.seek(0)
                selected_note: str = (
                    subprocess.check_output(
                        cmd.format(tmpfile.name, prompt, note_dir),
                        shell=True,
                    )
                    .decode(sys.stdout.encoding)
                    .strip()
                )
        except subprocess.CalledProcessError as err:
            # exit peacefully if the user doesn't select a note
            if not selected_note:
                sys.exit(0)
            raise err

    return notes[selected_note]


def view_note(note_name: str):
    """view a note"""
    try:
        with open(note_name, encoding="utf-8") as note:
            note_content: str = note.read()
            print(note_content)
    except FileNotFoundError:
        print_error(f"{note_name} does not exist")
        raise SystemExit(1)
    except PermissionError as err:
        raise err


def print_error(msg: str, warning: str = "ERR") -> None:
    """print an error message"""
    print(f"[{warning}] {msg}", file=sys.stderr)


def main():
    """main"""
    parser: argparse.ArgumentParser = argparse.ArgumentParser()
    actions = parser.add_mutually_exclusive_group()
    actions.add_argument(
        "-d", "--delete", action="store_true", help="Delete an existing note"
    )
    actions.add_argument(
        "-e", "--edit", action="store_true", help="Edit an existing note"
    )
    actions.add_argument(
        "-v", "--view", action="store_true", help="View an existing note"
    )
    parser.add_argument(
        "-f",
        "--filetype",
        default="md",
        help="Set the filetype of the new note (default: markdown)",
    )
    parser.add_argument(
        "--editor",
        default=getenv("EDITOR"),
        help="Chose the editor to use. (default: $EDITOR)",
    )
    actions.add_argument(
        "-l", "--list", action="store_true", help="List all created notes"
    )
    parser.add_argument(
        "--note_dir",
        default=f"{getenv('HOME')}/documents/personal/notes",
        help="Directory to store the note in",
    )
    parser.add_argument(
        "note",
        nargs="?",
        default=date.today(),
        help="The name of the note (default: today's date)",
    )

    args: argparse.Namespace = parser.parse_args()
    if args.delete:
        try:
            note: str = select_note(args.note_dir, "delete > ")
            Path(note).unlink()
            print(f"Deleted '{note}'")
            return
        except PermissionError as err:
            raise PermissionError from err
    elif args.edit:
        note: str = select_note(args.note_dir, "edit > ")
    elif args.list:
        list_notes(args.note_dir)
        raise SystemExit
    else:
        note: str = f"{args.note_dir}/{args.note}.{args.filetype}"
        if args.view:
            # TODO: handle mismatched filetypes
            view_note(note)
            raise SystemExit

    create_note(note, args.editor)


if __name__ == "__main__":
    main()
