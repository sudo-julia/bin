#!/usr/bin/env bash
# update system on arch, calls aur sep w extra util for aux programs (date-based) at end
# requires informant, pacman-contrib and either paru or yay
set -o pipefail

# set this to paru or yay
AUR_HELPER="yay"
# counter for if pacdiff has been run yet (dont touch)
PACDIFF_RUN=0
# find the user's home dir for script locations
USER_HOME="$( getent passwd "${SUDO_USER}" | cut -d':' -f6 )"

update_system() {
	# run the main update
	set -e
	informant check
	read -rp ":: Begin main update? [Y/n] " response
	case "$response" in
		y|Y)
			pacman -Syu
			pacdiff -o > /tmp/pacnew.out
			if [[ -z "${user}" ]]; then
				exit 0
			else
				get_user_input \
				":: Also update AUR packages? [Y/n] " \
				"sudo -u ${user} "${AUR_HELPER}" -Syua"\
				"Skipping AUR packages"
			fi
			;;
		*)
			printf -- '%s\n' "Cancelling update."
			exit 0
	esac
}

update_extras() {
	# update extra programs and non-arch package managers
	# if you don't want to use any of these, simply delete or comment-out the line
	if [[ -z "${user}" ]]; then
		return 1
	fi
	if [[ -s "${USER_HOME}/bin/upgrade_zinit" ]] \
	&& [[ -s "${USER_HOME}/bin/upgrade_pip" ]]; then
		sudo -u "${user}" zsh "${USER_HOME}/bin/upgrade-zinit"
		sudo -u "${user}" "${USER_HOME}/bin/upgrade-pip"
	fi
	if hash tldr >/dev/null; then
		sudo -u "${user}" /usr/bin/tldr --update \
		| sed 's/ cache/ tldr cache/'
	fi
	update_vim_plugins
	remove_orphans
	clear_paccache
	"${USER_HOME}/bin/get-installed"
	if [[ "$#" ]]; then
		echo "$1" >> "${USER_HOME}/bin/.lastDate"
		printf -- '\nNext full update will run on or after %d.\n' "$2"
	fi
}

update_vim_plugins() {
	# set your vim plugin manager's commands here
	printf -- '%s\n' "Updating NeoVim plugins..."
	sudo -u "${user}" nvim +PlugUpdate \
	&& sudo -u "${user}" nvim +PlugUpgrade \
	&& printf -- '%s\n' "NeoVim plugins updated."
}

remove_orphans() {
	# remove orphaned pacman packages
	if pacman -Qdtq >/dev/null; then
		printf -- '\n%s\n' "Orphaned packages are:"
		pacman -Qdt
		get_user_input \
		":: Remove orphan packages? [Y/n] " \
		"pacman -Rns --noconfirm $( pacman -Qdtq )" \
		"Leaving orphaned packages."
	else
		printf -- '%s\n' "No orphaned packages."
	fi
}

clear_paccache() {
	# get_user_input isn't in use because it borks the cache-clearing
	printf -- '%s\n' "Checking pacman cache for old packages..."
	paccache -d
	read -rp ":: Clear pacman cache? [Y/n] " confirm
	case "$confirm" in
		y|Y)
			paccache -rv && printf -- '%s\n' "Pacman cache cleared."
			;;
		*)
			printf -- '%s\n' "Skipping pacman cache."
	esac
}

check_last_date() {
	# check if it's time to run update_extras
	if [[ -z "${pathToLastDate}" ]]; then
		# if the user doesn't want to make lastDate file
		get_user_input \
		":: Update other programs? " \
		"update_extras" \
		"Skipping extra updates."
	elif [[ -n "${pathToLastDate}" ]] && [[ ! -s "${pathToLastDate}" ]]; then
		# if variable is set but file doesn't exist, create it
		echo '000000' > "${pathToLastDate}"
	elif [[ -s "${pathToLastDate}" ]]; then
		# check date to see if it's been a week since the last update
		lastDate="$( tail -n1 "${pathToLastDate}" )"
		currentDate="$( date "+%Y%m%d" )"
		currentDateLast="${currentDate:6}"
		# if (( currentDateLast >= 26 )); then
		#	 nextDate=$( check_month )
		# else
		#	 nextDate=$(( lastDate + 7 ))
		# fi
		nextDate=$(( lastDate + 7 ))
		if (( currentDate >= nextDate )); then
			update_extras "${currentDate}" "${nextDate}"
		fi
	fi
}

# TODO s(he's) br(ok)en
check_month() {
	# check the month and fix any incorrectly formatted dates
	currentMonth="${currentDate:4:2}"
	newYear="${currentDate:0:4}"
	newMonth=$(( currentMonth + 1 ))
	if (( newMonth > 12 )); then
		newMonth=1
		newYear=$(( newYear + 1 ))
	fi
	declare -a days_thirtyone
	days_thirtyone=(01 03 05 07 08 10 12)
	if [[ "${currentMonth}" =~ ${days_thirtyone[*]} ]]; then
		difference=$(( 7 - ( 31 - currentDateLast ) ))
	else
		difference=$(( 7 - ( 30 - currentDateLast ) ))
	fi
	if [[ "${#difference}" -eq 1 ]]; then
		difference=0${difference}
	fi
	newDate="${newYear}${newMonth}${difference}"
	echo "${newDate}"
}

check_root() {
	# exit program if not run as root
	set -o pipefail
	if (( "$( id -u )" != 0 )); then
		tput setaf 1
		printf -- '%s\n%s\n' "Error! Run as root." "Cancelling." >&2
		tput sgr0
		exit 1
	fi
}

get_user_input() {
	# get user confirmation for an action
	# args are: 1 - prompt, 2 - action if yes, 3 - action if no
	read -rp "$1" confirm
	case "$confirm" in
		y|Y)
			$2
			;;
		*)
			printf -- '%s\n' "$3"
	esac
}

print_pacdiff() {
	# print out any pacnew files
	if (( PACDIFF_RUN == 0 )) && [[ -s "/tmp/pacnew.out" ]]; then
		printf -- '\n%s\n%s\n' "Pacnew files:" "$( cat /tmp/pacnew.out )"
		PACDIFF_RUN=1
	fi
}


main() {
	check_root
	update_system
	check_last_date
	print_pacdiff
}

if getent passwd "jam" > /dev/null; then
	user="jam"
	pathToLastDate="${USER_HOME}/bin/.lastDate"
else
	# if this is unset, the program will ask if you'd like to update extras every time it's run
	# change the user you're updating for here
	# user=$( echo "$USER_HOME" | cut -d'/' -f3 ) # you can also use this to get $user automatically
	user=""
	# if you want extra updates to run automatically, place the file to read them from here
	pathToLastDate=""
fi

main
unset PACDIFF_RUN
unset USER_HOME
exit 0
